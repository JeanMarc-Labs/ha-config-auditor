"""Report generator for H.A.C.A v1.1.0 - Module 4."""
from __future__ import annotations

from datetime import datetime
import json
import logging
from pathlib import Path
from typing import Any

from homeassistant.core import HomeAssistant

from .const import REPORTS_DIR

_LOGGER = logging.getLogger(__name__)


class ReportGenerator:
    """Generate comprehensive reports from audit data."""

    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize report generator."""
        self.hass = hass
        self._reports_dir = Path(hass.config.config_dir) / REPORTS_DIR
        self._reports_dir.mkdir(exist_ok=True)

    async def generate_markdown(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
    ) -> str:
        """Generate comprehensive Markdown report."""
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        health_score = summary.get("health_score", 0)
        
        report = f"""# ðŸ“Š H.A.C.A Configuration Report

**Generated:** {timestamp}  
**Health Score:** {health_score}% {self._get_status_emoji(health_score)}

---

## ðŸ“ˆ Executive Summary

| Metric | Value |
|--------|-------|
| Health Score | {health_score}% |
| Automation Issues | {summary.get('automation_issues', 0)} |
| Entity Issues | {summary.get('entity_issues', 0)} |
| Total Issues | {summary.get('total_issues', 0)} |

### Overall Status
{self._get_status_text(health_score)}

---

## ðŸ¤– Automation Issues ({len(automation_issues)})

"""
        
        if automation_issues:
            # Group by severity
            high = [i for i in automation_issues if i.get('severity') == 'high']
            medium = [i for i in automation_issues if i.get('severity') == 'medium']
            low = [i for i in automation_issues if i.get('severity') == 'low']
            
            if high:
                report += f"### ðŸ”´ High Severity ({len(high)})\n\n"
                for issue in high[:10]:
                    report += self._format_issue(issue)
            
            if medium:
                report += f"\n### ðŸŸ  Medium Severity ({len(medium)})\n\n"
                for issue in medium[:10]:
                    report += self._format_issue(issue)
            
            if low:
                report += f"\n### ðŸŸ¡ Low Severity ({len(low)})\n\n"
                report += f"*{len(low)} low severity issues found*\n\n"
        else:
            report += "âœ… **No automation issues detected!**\n\n"
        
        report += "---\n\n"
        
        # Entity issues
        report += f"## ðŸ“ Entity Issues ({len(entity_issues)})\n\n"
        
        if entity_issues:
            zombies = [i for i in entity_issues if i.get('type') == 'zombie_entity']
            unavailable = [i for i in entity_issues if i.get('type') == 'unavailable']
            
            if zombies:
                report += f"### ðŸ‘» Zombie Entities ({len(zombies)})\n\n"
                for issue in zombies[:5]:
                    report += f"- **{issue.get('entity_id')}**: {issue.get('message')}\n"
                report += "\n"
            
            if unavailable:
                report += f"### âŒ Unavailable ({len(unavailable)})\n\n"
                for issue in unavailable[:5]:
                    report += f"- {issue.get('entity_id')}\n"
                report += "\n"
        else:
            report += "âœ… **No entity issues detected!**\n\n"
        
        report += "---\n\n"
        
        # Recommendations
        report += "## ðŸ’¡ Recommendations\n\n"
        report += self._generate_recommendations(health_score, automation_issues, entity_issues)
        
        report += f"\n\n---\n\n*Report generated by H.A.C.A v1.1.0 on {timestamp}*\n"
        
        # Save report
        filename = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        filepath = self._reports_dir / filename
        
        def write_report():
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(report)
        
        await self.hass.async_add_executor_job(write_report)
        
        _LOGGER.info("Generated Markdown report: %s", filepath)
        return str(filepath)

    async def generate_json(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
    ) -> str:
        """Generate JSON report."""
        
        report_data = {
            "timestamp": datetime.now().isoformat(),
            "version": "1.1.0",
            "summary": summary,
            "issues": {
                "automation": automation_issues,
                "entity": entity_issues,
            },
            "statistics": {
                "by_severity": self._count_by_severity(automation_issues + entity_issues),
                "by_type": self._count_by_type(automation_issues + entity_issues),
            }
        }
        
        filename = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        filepath = self._reports_dir / filename
        
        def write_json():
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(report_data, f, indent=2, default=str)
        
        await self.hass.async_add_executor_job(write_json)
        
        _LOGGER.info("Generated JSON report: %s", filepath)
        return str(filepath)

    async def generate_pdf(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
    ) -> str:
        """Generate PDF report."""
        try:
            from fpdf import FPDF
        except ImportError:
            _LOGGER.error("fpdf2 not installed. Cannot generate PDF report.")
            return ""

        class HACA_PDF(FPDF):
            def header(self):
                self.set_font("helvetica", "B", 15)
                self.cell(0, 10, "H.A.C.A Configuration Report", border=True, ln=1, align="C")
                self.ln(5)

            def footer(self):
                self.set_y(-15)
                self.set_font("helvetica", "I", 8)
                self.cell(0, 10, f"Page {self.page_no()}/{{nb}}", align="C")

        pdf = HACA_PDF()
        pdf.add_page()
        pdf.set_font("helvetica", "", 12)
        
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        health_score = summary.get("health_score", 0)

        # Executive Summary
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, "Executive Summary", ln=1)
        pdf.set_font("helvetica", "", 12)
        pdf.cell(0, 8, f"Generated: {timestamp}", ln=1)
        pdf.cell(0, 8, f"Health Score: {health_score}%", ln=1)
        pdf.ln(5)

        # Issues counts
        pdf.cell(0, 8, f"Automation Issues: {summary.get('automation_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"Entity Issues: {summary.get('entity_issues', 0)}", ln=1)
        pdf.ln(10)

        # Automations
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, f"Automation Issues ({len(automation_issues)})", ln=1)
        pdf.set_font("helvetica", "", 10)
        
        for issue in automation_issues[:20]: # Limit to 20 for PDF
            severity = issue.get('severity', 'low').upper()
            entity = issue.get('entity_id' , issue.get('alias', 'N/A'))
            msg = issue.get('message', '')
            pdf.set_font("helvetica", "B", 10)
            pdf.cell(0, 6, f"[{severity}] {entity}", ln=1)
            pdf.set_font("helvetica", "", 10)
            pdf.multi_cell(0, 5, msg)
            pdf.ln(2)

        # Entities
        pdf.add_page()
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, f"Entity Issues ({len(entity_issues)})", ln=1)
        pdf.set_font("helvetica", "", 10)
        
        for issue in entity_issues[:30]:
            pdf.cell(0, 6, f"- {issue.get('entity_id')}: {issue.get('message')}", ln=1)

        filename = f"report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
        filepath = self._reports_dir / filename
        
        def save_pdf():
            pdf.output(str(filepath))
            
        await self.hass.async_add_executor_job(save_pdf)
        _LOGGER.info("Generated PDF report: %s", filepath)
        return str(filepath)

    async def get_report_content(self, filename: str) -> dict[str, Any] | None:
        """Get the content of a report file."""
        filepath = self._reports_dir / filename
        if not filepath.exists() or not filepath.is_file():
            return None
            
        def read_file():
            if filepath.suffix == '.json':
                with open(filepath, "r", encoding="utf-8") as f:
                    return {"content": json.load(f), "type": "json"}
            elif filepath.suffix == '.md':
                with open(filepath, "r", encoding="utf-8") as f:
                    return {"content": f.read(), "type": "markdown"}
            elif filepath.suffix == '.pdf':
                return {"content": "PDF content is binary", "type": "pdf"}
            return None

        return await self.hass.async_add_executor_job(read_file)

    def _format_issue(self, issue: dict) -> str:
        """Format issue for markdown."""
        entity_id = issue.get('entity_id', issue.get('alias', 'N/A'))
        message = issue.get('message', '')
        recommendation = issue.get('recommendation', '')
        
        output = f"#### {entity_id}\n\n"
        output += f"**Issue:** {message}\n\n"
        if recommendation:
            output += f"**Fix:** {recommendation}\n\n"
        return output

    def _get_status_emoji(self, score: int) -> str:
        """Get status emoji."""
        if score >= 90:
            return "âœ…"
        elif score >= 75:
            return "ðŸ‘"
        elif score >= 60:
            return "âš ï¸"
        else:
            return "âŒ"

    def _get_status_text(self, score: int) -> str:
        """Get status explanation."""
        if score >= 90:
            return "âœ… **Excellent!** Your configuration follows best practices."
        elif score >= 75:
            return "ðŸ‘ **Good.** Minor improvements possible."
        elif score >= 60:
            return "âš ï¸ **Fair.** Several improvements recommended."
        else:
            return "âŒ **Poor.** Action required."

    def _generate_recommendations(
        self,
        score: int,
        auto_issues: list,
        entity_issues: list
    ) -> str:
        """Generate recommendations."""
        recs = []
        
        if any(i.get('type') == 'zombie_entity' for i in entity_issues):
            recs.append("1. ðŸ”´ **Critical:** Remove zombie entity references")
        
        if any(i.get('type') == 'device_id_in_trigger' for i in auto_issues):
            recs.append("2. ðŸ”´ **High Priority:** Convert device_id to entity_id")
        
        if score < 75:
            recs.append("3. ðŸ“Š **General:** Run weekly scans to track progress")
        
        if not recs:
            recs.append("âœ… **Great job!** Continue monitoring weekly.")
        
        return "\n".join(recs)

    def _count_by_severity(self, issues: list) -> dict:
        """Count by severity."""
        counts = {"high": 0, "medium": 0, "low": 0}
        for issue in issues:
            severity = issue.get('severity', 'low')
            counts[severity] = counts.get(severity, 0) + 1
        return counts

    def _count_by_type(self, issues: list) -> dict:
        """Count by type."""
        counts = {}
        for issue in issues:
            issue_type = issue.get('type', 'unknown')
            counts[issue_type] = counts.get(issue_type, 0) + 1
        return counts

    def list_reports(self) -> list[dict]:
        """List all generated reports grouped by session."""
        sessions = {}
        
        # Regex to extract timestamp: report_20231027_123456.md -> 20231027_123456
        import re
        pattern = re.compile(r"report_(\d{8}_\d{6})")
        
        for report_file in self._reports_dir.glob("report_*"):
            match = pattern.match(report_file.stem)
            if not match:
                continue
                
            session_id = match.group(1)
            stat = report_file.stat()
            fmt = report_file.suffix[1:]
            
            if session_id not in sessions:
                sessions[session_id] = {
                    "session_id": session_id,
                    "created": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "formats": {}
                }
            
            sessions[session_id]["formats"][fmt] = {
                "name": report_file.name,
                "size": stat.st_size
            }
        
        # Sort by session ID (timestamp) descending
        sorted_sessions = sorted(sessions.values(), key=lambda x: x["session_id"], reverse=True)
        return sorted_sessions[:20]  # Last 20 sessions
