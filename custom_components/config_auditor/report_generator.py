"""Report generator for H.A.C.A v1.1.0 - Module 4."""
from __future__ import annotations

from datetime import datetime
import json
import logging
from pathlib import Path
from typing import Any

from homeassistant.core import HomeAssistant

from .const import REPORTS_DIR

_LOGGER = logging.getLogger(__name__)

# Default translations (English)
DEFAULT_TRANSLATIONS = {
    "title": "H.A.C.A Configuration Report",
    "generated": "Generated",
    "health_score": "Health Score",
    "executive_summary": "Executive Summary",
    "metric": "Metric",
    "value": "Value",
    "overall_status": "Overall Status",
    "automation_issues": "Automation Issues",
    "entity_issues": "Entity Issues",
    "total_issues": "Total Issues",
    "script_issues": "Script Issues",
    "scene_issues": "Scene Issues",
    "performance_issues": "Performance Issues",
    "security_issues": "Security Issues",
    "high_severity": "High Severity",
    "medium_severity": "Medium Severity",
    "low_severity": "Low Severity",
    "low_severity_issues_found": "low severity issues found",
    "no_automation_issues": "No automation issues detected!",
    "zombie_entities": "Zombie Entities",
    "unavailable": "Unavailable",
    "ghost_entities": "Ghost Entities",
    "broken_device_references": "Broken Device References",
    "references_nonexistent_device": "References non-existent device",
    "no_entity_issues": "No entity issues detected!",
    "recommendations": "Recommendations",
    "critical_remove_zombie": "Critical: Remove zombie entity references",
    "high_priority_device": "High Priority: Resolve device integration issues",
    "ghost_cleanup": "Ghost Cleanup: Purge orphaned entity registry entries",
    "general_weekly_scan": "General: Run weekly scans to track progress",
    "great_job": "Great job! Continue monitoring weekly.",
    "report_generated_by": "Report generated by H.A.C.A",
    "status_excellent": "Excellent! Your configuration follows best practices.",
    "status_good": "Good. Minor improvements possible.",
    "status_fair": "Fair. Several improvements recommended.",
    "status_poor": "Poor. Action required.",
    "issue": "Issue",
    "fix": "Fix",
    "page": "Page",
}

# French translations
FR_TRANSLATIONS = {
    "title": "Rapport de Configuration H.A.C.A",
    "generated": "GÃ©nÃ©rÃ©",
    "health_score": "Score de SantÃ©",
    "executive_summary": "RÃ©sumÃ© ExÃ©cutif",
    "metric": "MÃ©trique",
    "value": "Valeur",
    "overall_status": "Statut Global",
    "automation_issues": "ProblÃ¨mes d'Automatisations",
    "entity_issues": "ProblÃ¨mes d'EntitÃ©s",
    "total_issues": "Total des ProblÃ¨mes",
    "script_issues": "ProblÃ¨mes de Scripts",
    "scene_issues": "ProblÃ¨mes de ScÃ¨nes",
    "performance_issues": "ProblÃ¨mes de Performance",
    "security_issues": "ProblÃ¨mes de SÃ©curitÃ©",
    "high_severity": "SÃ©vÃ©ritÃ© Ã‰levÃ©e",
    "medium_severity": "SÃ©vÃ©ritÃ© Moyenne",
    "low_severity": "Faible SÃ©vÃ©ritÃ©",
    "low_severity_issues_found": "problÃ¨mes de faible sÃ©vÃ©ritÃ© trouvÃ©s",
    "no_automation_issues": "Aucun problÃ¨me d'automation dÃ©tectÃ© !",
    "zombie_entities": "EntitÃ©s Zombies",
    "unavailable": "Indisponibles",
    "ghost_entities": "EntitÃ©s FantÃ´mes",
    "broken_device_references": "RÃ©fÃ©rences de Device CassÃ©es",
    "references_nonexistent_device": "RÃ©fÃ©rence un device inexistant",
    "no_entity_issues": "Aucun problÃ¨me d'entitÃ© dÃ©tectÃ© !",
    "recommendations": "Recommandations",
    "critical_remove_zombie": "Critique : Supprimer les rÃ©fÃ©rences aux entitÃ©s zombies",
    "high_priority_device": "Haute PrioritÃ© : RÃ©soudre les problÃ¨mes d'intÃ©gration de device",
    "ghost_cleanup": "Nettoyage des FantÃ´mes : Purger les entrÃ©es orphelines du registre d'entitÃ©s",
    "general_weekly_scan": "GÃ©nÃ©ral : Effectuer des scans hebdomadaires pour suivre les progrÃ¨s",
    "great_job": "Excellent travail ! Continuez Ã  surveiller chaque semaine.",
    "report_generated_by": "Rapport gÃ©nÃ©rÃ© par H.A.C.A",
    "status_excellent": "Excellent ! Votre configuration suit les bonnes pratiques.",
    "status_good": "Bon. De lÃ©gÃ¨res amÃ©liorations sont possibles.",
    "status_fair": "Correct. Plusieurs amÃ©liorations recommandÃ©es.",
    "status_poor": "Insuffisant. Une action est requise.",
    "issue": "ProblÃ¨me",
    "fix": "Correction",
    "page": "Page",
}


class ReportGenerator:
    """Generate comprehensive reports from audit data."""

    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize report generator."""
        self.hass = hass
        self._reports_dir = Path(hass.config.config_dir) / REPORTS_DIR
        self._reports_dir.mkdir(exist_ok=True)
        self._translations = DEFAULT_TRANSLATIONS

    def _load_translations(self, language: str) -> dict:
        """Load translations for the specified language."""
        if language == "fr":
            return {**DEFAULT_TRANSLATIONS, **FR_TRANSLATIONS}
        return DEFAULT_TRANSLATIONS

    def _t(self, key: str) -> str:
        """Get translation for key."""
        return self._translations.get(key, DEFAULT_TRANSLATIONS.get(key, key))

    async def generate_all_reports(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
        language: str = "en",
    ) -> dict[str, str]:
        """Generate all report formats with the same timestamp."""
        # Load translations
        self._translations = self._load_translations(language)
        
        # Generate a single timestamp for all reports
        timestamp = datetime.now()
        timestamp_str = timestamp.strftime("%Y%m%d_%H%M%S")
        
        # Generate all reports with the same timestamp
        md_path = await self._generate_markdown_with_timestamp(
            summary, automation_issues, entity_issues, timestamp, timestamp_str
        )
        json_path = await self._generate_json_with_timestamp(
            summary, automation_issues, entity_issues, timestamp, timestamp_str
        )
        pdf_path = await self._generate_pdf_with_timestamp(
            summary, automation_issues, entity_issues, timestamp, timestamp_str
        )
        
        return {
            "markdown": md_path,
            "json": json_path,
            "pdf": pdf_path,
            "timestamp": timestamp_str
        }

    async def _generate_markdown_with_timestamp(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
        timestamp: datetime,
        timestamp_str: str,
    ) -> str:
        """Generate Markdown report with provided timestamp."""
        
        health_score = summary.get("health_score", 0)
        timestamp_display = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        
        report = f"""# ðŸ“Š {self._t("title")}

**{self._t("generated")}:** {timestamp_display}  
**{self._t("health_score")}:** {health_score}% {self._get_status_emoji(health_score)}

---

## ðŸ“ˆ {self._t("executive_summary")}

| {self._t("metric")} | {self._t("value")} |
|--------|-------|
| {self._t("health_score")} | {health_score}% |
| {self._t("automation_issues")} | {summary.get('automation_issues', 0)} |
| {self._t("entity_issues")} | {summary.get('entity_issues', 0)} |
| {self._t("total_issues")} | {summary.get('total_issues', 0)} |
| {self._t("script_issues")} | {summary.get('script_issues', 0)} |
| {self._t("scene_issues")} | {summary.get('scene_issues', 0)} |
| {self._t("performance_issues")} | {summary.get('performance_issues', 0)} |
| {self._t("security_issues")} | {summary.get('security_issues', 0)} |

### {self._t("overall_status")}
{self._get_status_text(health_score)}

---

## ðŸ¤– {self._t("automation_issues")} ({len(automation_issues)})

"""
        
        if automation_issues:
            # Group by severity
            high = [i for i in automation_issues if i.get('severity') == 'high']
            medium = [i for i in automation_issues if i.get('severity') == 'medium']
            low = [i for i in automation_issues if i.get('severity') == 'low']
            
            if high:
                report += f"### ðŸ”´ {self._t('high_severity')} ({len(high)})\n\n"
                for issue in high[:10]:
                    report += self._format_issue(issue)
            
            if medium:
                report += f"\n### ðŸŸ  {self._t('medium_severity')} ({len(medium)})\n\n"
                for issue in medium[:10]:
                    report += self._format_issue(issue)
            
            if low:
                report += f"\n### ðŸŸ¡ {self._t('low_severity')} ({len(low)})\n\n"
                report += f"*{len(low)} {self._t('low_severity_issues_found')}*\n\n"
        else:
            report += f"âœ… **{self._t('no_automation_issues')}**\n\n"
        
        report += "---\n\n"
        
        # Entity issues
        report += f"## ðŸ“ {self._t('entity_issues')} ({len(entity_issues)})\n\n"
        
        if entity_issues:
            zombies = [i for i in entity_issues if i.get('type') == 'zombie_entity']
            unavailable = [i for i in entity_issues if i.get('type') == 'unavailable']
            
            if zombies:
                report += f"### ðŸ‘» {self._t('zombie_entities')} ({len(zombies)})\n\n"
                for issue in zombies[:5]:
                    report += f"- **{issue.get('entity_id')}**: {issue.get('message')}\n"
                report += "\n"
            
            if unavailable:
                report += f"### âŒ {self._t('unavailable')} ({len(unavailable)})\n\n"
                for issue in unavailable[:5]:
                    report += f"- {issue.get('entity_id')}\n"
                report += "\n"
                
            ghosts = [i for i in entity_issues if i.get('type') == 'ghost_registry_entry']
            if ghosts:
                report += f"### ðŸ‘» {self._t('ghost_entities')} ({len(ghosts)})\n\n"
                for issue in ghosts[:5]:
                    report += f"- **{issue.get('entity_id')}**: {issue.get('message')}\n"
                report += "\n"
                
            broken_devices = [i for i in entity_issues if i.get('type') == 'broken_device_reference']
            if broken_devices:
                report += f"### ðŸ“± {self._t('broken_device_references')} ({len(broken_devices)})\n\n"
                for issue in broken_devices[:5]:
                    report += f"- **{issue.get('entity_id')}**: {self._t('references_nonexistent_device')} {issue.get('device_id')}\n"
                report += "\n"
        else:
            report += f"âœ… **{self._t('no_entity_issues')}**\n\n"
        
        report += "---\n\n"
        
        # Recommendations
        report += f"## ðŸ’¡ {self._t('recommendations')}\n\n"
        report += self._generate_recommendations(health_score, automation_issues, entity_issues)
        
        report += f"\n\n---\n\n*{self._t('report_generated_by')} v1.3.0 - {timestamp_display}*\n"
        
        # Save report with provided timestamp
        filename = f"report_{timestamp_str}.md"
        filepath = self._reports_dir / filename
        
        def write_report():
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(report)
        
        await self.hass.async_add_executor_job(write_report)
        
        _LOGGER.info("Generated Markdown report: %s", filepath)
        return str(filepath)

    async def _generate_json_with_timestamp(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
        timestamp: datetime,
        timestamp_str: str,
    ) -> str:
        """Generate JSON report with provided timestamp."""
        
        report_data = {
            "timestamp": timestamp.isoformat(),
            "version": "1.3.0",
            "language": self._translations.get("title", "H.A.C.A Configuration Report"),
            "summary": summary,
            "issues": {
                "automation": automation_issues,
                "entity": entity_issues,
            },
            "statistics": {
                "by_severity": self._count_by_severity(automation_issues + entity_issues),
                "by_type": self._count_by_type(automation_issues + entity_issues),
            }
        }
        
        filename = f"report_{timestamp_str}.json"
        filepath = self._reports_dir / filename
        
        def write_json():
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(report_data, f, indent=2, default=str)
        
        await self.hass.async_add_executor_job(write_json)
        
        _LOGGER.info("Generated JSON report: %s", filepath)
        return str(filepath)

    async def _generate_pdf_with_timestamp(
        self,
        summary: dict[str, Any],
        automation_issues: list[dict],
        entity_issues: list[dict],
        timestamp: datetime,
        timestamp_str: str,
    ) -> str:
        """Generate PDF report with provided timestamp."""
        try:
            from fpdf import FPDF
        except ImportError:
            _LOGGER.error("fpdf2 not installed. Cannot generate PDF report.")
            return ""

        t = self._t  # Shortcut
        timestamp_display = timestamp.strftime("%Y-%m-%d %H:%M:%S")
        health_score = summary.get("health_score", 0)

        class HACA_PDF(FPDF):
            def __init__(self, translations):
                super().__init__()
                self._translations = translations
                
            def _t(self, key):
                """Get translation for key."""
                return self._translations.get(key, DEFAULT_TRANSLATIONS.get(key, key))
                
            def header(self):
                self.set_font("helvetica", "B", 15)
                self.cell(0, 10, self._t("title"), border=True, ln=1, align="C")
                self.ln(5)

            def footer(self):
                self.set_y(-15)
                self.set_font("helvetica", "I", 8)
                self.cell(0, 10, f"{self._t('page')} {self.page_no()}/{{nb}}", align="C")

        pdf = HACA_PDF(self._translations)
        pdf.add_page()
        pdf.set_font("helvetica", "", 12)

        # Executive Summary
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, t("executive_summary"), ln=1)
        pdf.set_font("helvetica", "", 12)
        pdf.cell(0, 8, f"{t('generated')}: {timestamp_display}", ln=1)
        pdf.cell(0, 8, f"{t('health_score')}: {health_score}%", ln=1)
        pdf.ln(5)

        # Issues counts
        pdf.cell(0, 8, f"{t('automation_issues')}: {summary.get('automation_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"{t('entity_issues')}: {summary.get('entity_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"{t('script_issues')}: {summary.get('script_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"{t('scene_issues')}: {summary.get('scene_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"{t('performance_issues')}: {summary.get('performance_issues', 0)}", ln=1)
        pdf.cell(0, 8, f"{t('security_issues')}: {summary.get('security_issues', 0)}", ln=1)
        pdf.ln(5)
        
        # Status
        pdf.set_font("helvetica", "B", 12)
        pdf.cell(0, 8, t("overall_status"), ln=1)
        pdf.set_font("helvetica", "", 10)
        pdf.multi_cell(0, 6, self._get_status_text_pdf(health_score))
        pdf.ln(10)

        # Automations
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, f"{t('automation_issues')} ({len(automation_issues)})", ln=1)
        pdf.set_font("helvetica", "", 10)
        
        if automation_issues:
            for issue in automation_issues[:20]:  # Limit to 20 for PDF
                severity = issue.get('severity', 'low').upper()
                entity = issue.get('entity_id', issue.get('alias', 'N/A'))
                msg = issue.get('message', '')
                pdf.set_font("helvetica", "B", 10)
                pdf.cell(0, 6, f"[{severity}] {entity}", ln=1)
                pdf.set_font("helvetica", "", 10)
                pdf.multi_cell(0, 5, msg)
                pdf.ln(2)
        else:
            pdf.cell(0, 8, f"[OK] {t('no_automation_issues')}", ln=1)

        # Entities
        pdf.add_page()
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, f"{t('entity_issues')} ({len(entity_issues)})", ln=1)
        pdf.set_font("helvetica", "", 10)
        
        if entity_issues:
            for issue in entity_issues[:30]:
                pdf.cell(0, 6, f"- {issue.get('entity_id')}: {issue.get('message')}", ln=1)
        else:
            pdf.cell(0, 8, f"[OK] {t('no_entity_issues')}", ln=1)
        
        # Recommendations
        pdf.ln(10)
        pdf.set_font("helvetica", "B", 14)
        pdf.cell(0, 10, f">> {t('recommendations')}", ln=1)
        pdf.set_font("helvetica", "", 10)
        pdf.multi_cell(0, 6, self._generate_recommendations_pdf(health_score, automation_issues, entity_issues))
        
        # Footer
        pdf.ln(10)
        pdf.set_font("helvetica", "I", 9)
        pdf.cell(0, 8, f"{t('report_generated_by')} v1.3.0 - {timestamp_display}", ln=1)

        filename = f"report_{timestamp_str}.pdf"
        filepath = self._reports_dir / filename
        
        def save_pdf():
            pdf.output(str(filepath))
            
        await self.hass.async_add_executor_job(save_pdf)
        _LOGGER.info("Generated PDF report: %s", filepath)
        return str(filepath)

    async def get_report_content(self, filename: str) -> dict[str, Any] | None:
        """Get the content of a report file."""
        filepath = self._reports_dir / filename
        if not filepath.exists() or not filepath.is_file():
            return None
            
        def read_file():
            if filepath.suffix == '.json':
                with open(filepath, "r", encoding="utf-8") as f:
                    return {"content": json.load(f), "type": "json"}
            elif filepath.suffix == '.md':
                with open(filepath, "r", encoding="utf-8") as f:
                    return {"content": f.read(), "type": "markdown"}
            elif filepath.suffix == '.pdf':
                return {"content": "PDF content is binary", "type": "pdf"}
            return None

        return await self.hass.async_add_executor_job(read_file)

    def _format_issue(self, issue: dict) -> str:
        """Format issue for markdown."""
        entity_id = issue.get('entity_id', issue.get('alias', 'N/A'))
        message = issue.get('message', '')
        recommendation = issue.get('recommendation', '')
        
        output = f"#### {entity_id}\n\n"
        output += f"**{self._t('issue')}:** {message}\n\n"
        if recommendation:
            output += f"**{self._t('fix')}:** {recommendation}\n\n"
        return output

    def _get_status_emoji(self, score: int) -> str:
        """Get status emoji."""
        if score >= 90:
            return "âœ…"
        elif score >= 75:
            return "ðŸ‘"
        elif score >= 60:
            return "âš ï¸"
        else:
            return "âŒ"

    def _get_status_text(self, score: int) -> str:
        """Get status explanation."""
        if score >= 90:
            return f"âœ… **{self._t('status_excellent')}**"
        elif score >= 75:
            return f"ðŸ‘ **{self._t('status_good')}**"
        elif score >= 60:
            return f"âš ï¸ **{self._t('status_fair')}**"
        else:
            return f"âŒ **{self._t('status_poor')}**"

    def _get_status_text_pdf(self, score: int) -> str:
        """Get status explanation for PDF (no emojis)."""
        if score >= 90:
            return f"[EXCELLENT] {self._t('status_excellent')}"
        elif score >= 75:
            return f"[GOOD] {self._t('status_good')}"
        elif score >= 60:
            return f"[FAIR] {self._t('status_fair')}"
        else:
            return f"[POOR] {self._t('status_poor')}"

    def _generate_recommendations(
        self,
        score: int,
        auto_issues: list,
        entity_issues: list
    ) -> str:
        """Generate recommendations."""
        recs = []
        
        if any(i.get('type') == 'zombie_entity' for i in entity_issues):
            recs.append(f"1. [CRITICAL] **{self._t('critical_remove_zombie')}**")
        
        if any(i.get('type') == 'device_id_in_trigger' for i in auto_issues) or \
           any(i.get('type') == 'broken_device_reference' for i in entity_issues):
            recs.append(f"2. [HIGH] **{self._t('high_priority_device')}**")
            
        if any(i.get('type') == 'ghost_registry_entry' for i in entity_issues):
            recs.append(f"3. [GHOST] **{self._t('ghost_cleanup')}**")
        
        if score < 75:
            recs.append(f"4. [GENERAL] **{self._t('general_weekly_scan')}**")
        
        if not recs:
            recs.append(f"[OK] **{self._t('great_job')}**")
        
        return "\n".join(recs)

    def _generate_recommendations_pdf(
        self,
        score: int,
        auto_issues: list,
        entity_issues: list
    ) -> str:
        """Generate recommendations for PDF (no emojis)."""
        recs = []
        
        if any(i.get('type') == 'zombie_entity' for i in entity_issues):
            recs.append(f"1. [CRITICAL] {self._t('critical_remove_zombie')}")
        
        if any(i.get('type') == 'device_id_in_trigger' for i in auto_issues) or \
           any(i.get('type') == 'broken_device_reference' for i in entity_issues):
            recs.append(f"2. [HIGH] {self._t('high_priority_device')}")
            
        if any(i.get('type') == 'ghost_registry_entry' for i in entity_issues):
            recs.append(f"3. [GHOST] {self._t('ghost_cleanup')}")
        
        if score < 75:
            recs.append(f"4. [GENERAL] {self._t('general_weekly_scan')}")
        
        if not recs:
            recs.append(f"[OK] {self._t('great_job')}")
        
        return "\n".join(recs)

    def _count_by_severity(self, issues: list) -> dict:
        """Count by severity."""
        counts = {"high": 0, "medium": 0, "low": 0}
        for issue in issues:
            severity = issue.get('severity', 'low')
            counts[severity] = counts.get(severity, 0) + 1
        return counts

    def _count_by_type(self, issues: list) -> dict:
        """Count by type."""
        counts = {}
        for issue in issues:
            issue_type = issue.get('type', 'unknown')
            counts[issue_type] = counts.get(issue_type, 0) + 1
        return counts

    def list_reports(self) -> list[dict]:
        """List all generated reports grouped by session."""
        sessions = {}
        
        # Regex to extract timestamp: report_20231027_123456.md -> 20231027_123456
        import re
        pattern = re.compile(r"report_(\d{8}_\d{6})")
        
        for report_file in self._reports_dir.glob("report_*"):
            match = pattern.match(report_file.stem)
            if not match:
                continue
                
            session_id = match.group(1)
            stat = report_file.stat()
            fmt = report_file.suffix[1:]
            
            if session_id not in sessions:
                sessions[session_id] = {
                    "session_id": session_id,
                    "created": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    "formats": {}
                }
            
            sessions[session_id]["formats"][fmt] = {
                "name": report_file.name,
                "size": stat.st_size
            }
        
        # Sort by session ID (timestamp) descending
        sorted_sessions = sorted(sessions.values(), key=lambda x: x["session_id"], reverse=True)
        return sorted_sessions[:20]  # Last 20 sessions

    async def delete_report_session(self, session_id: str) -> dict:
        """Delete all report files for a given session ID."""
        import re
        
        deleted_files = []
        errors = []
        
        # Find all files matching this session
        pattern = re.compile(f"report_{re.escape(session_id)}")
        
        for report_file in self._reports_dir.glob("report_*"):
            if pattern.match(report_file.name):
                try:
                    def delete_file():
                        report_file.unlink()
                    
                    await self.hass.async_add_executor_job(delete_file)
                    deleted_files.append(report_file.name)
                    _LOGGER.info("Deleted report file: %s", report_file.name)
                except Exception as e:
                    errors.append(f"{report_file.name}: {str(e)}")
                    _LOGGER.error("Failed to delete report file %s: %s", report_file.name, e)
        
        if not deleted_files and not errors:
            return {
                "success": False,
                "error": f"No reports found for session {session_id}"
            }
        
        return {
            "success": len(deleted_files) > 0,
            "deleted_count": len(deleted_files),
            "deleted_files": deleted_files,
            "errors": errors
        }
